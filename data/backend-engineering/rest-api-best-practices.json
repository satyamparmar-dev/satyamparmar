{
  "title": "REST API Best Practices for Backend Engineers",
  "slug": "rest-api-best-practices",
  "date": "2025-01-18",
  "author": "Satyam Parmar",
  "tags": ["Backend Engineering", "REST API", "Best Practices", "HTTP"],
  "excerpt": "Learn essential REST API design principles, HTTP status codes, authentication, versioning, and performance optimization techniques.",
  "content": "# REST API Best Practices for Backend Engineers\n\nBuilding robust, scalable REST APIs requires following established conventions and best practices. This guide covers everything you need to know to create production-ready APIs.\n\n## URL Design\n\n### Use Nouns, Not Verbs\n\n```http\n# Good\nGET /api/users\nPOST /api/users\nPUT /api/users/123\nDELETE /api/users/123\n\n# Bad\nGET /api/getUsers\nPOST /api/createUser\nPOST /api/updateUser\nPOST /api/deleteUser\n```\n\n### Use Plural Nouns\n\n```http\n# Good\nGET /api/users\nGET /api/orders\nGET /api/products\n\n# Bad\nGET /api/user\nGET /api/order\nGET /api/product\n```\n\n### Use Hierarchical Structure\n\n```http\n# Good\nGET /api/users/123/orders\nGET /api/users/123/orders/456\n\n# Bad\nGET /api/userOrders?userId=123\nGET /api/orderDetails?orderId=456\n```\n\n## HTTP Status Codes\n\n### Success Codes\n\n```javascript\n// 200 OK - Successful GET, PUT, PATCH\napp.get('/api/users/:id', (req, res) => {\n  const user = getUserById(req.params.id);\n  res.status(200).json(user);\n});\n\n// 201 Created - Successful POST\napp.post('/api/users', (req, res) => {\n  const user = createUser(req.body);\n  res.status(201).json(user);\n});\n\n// 204 No Content - Successful DELETE\napp.delete('/api/users/:id', (req, res) => {\n  deleteUser(req.params.id);\n  res.status(204).send();\n});\n```\n\n**Java/Spring Boot:**\n```java\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    // 200 OK - Successful GET, PUT, PATCH\n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        User user = userService.findById(id);\n        return ResponseEntity.ok(user);\n    }\n    \n    // 201 Created - Successful POST\n    @PostMapping\n    public ResponseEntity<User> createUser(@Valid @RequestBody User user) {\n        User createdUser = userService.save(user);\n        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);\n    }\n    \n    // 204 No Content - Successful DELETE\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        userService.deleteById(id);\n        return ResponseEntity.noContent().build();\n    }\n}\n```\n\n### Error Codes\n\n```javascript\n// 400 Bad Request - Invalid input\napp.post('/api/users', (req, res) => {\n  if (!req.body.email) {\n    return res.status(400).json({\n      error: 'Email is required'\n    });\n  }\n});\n\n// 401 Unauthorized - Authentication required\napp.get('/api/profile', authenticateToken, (req, res) => {\n  res.json(req.user);\n});\n\n// 403 Forbidden - Access denied\napp.delete('/api/users/:id', (req, res) => {\n  if (req.user.id !== req.params.id) {\n    return res.status(403).json({\n      error: 'Access denied'\n    });\n  }\n});\n\n// 404 Not Found - Resource doesn't exist\napp.get('/api/users/:id', (req, res) => {\n  const user = getUserById(req.params.id);\n  if (!user) {\n    return res.status(404).json({\n      error: 'User not found'\n    });\n  }\n  res.json(user);\n});\n\n// 422 Unprocessable Entity - Validation failed\napp.post('/api/users', (req, res) => {\n  const errors = validateUser(req.body);\n  if (errors.length > 0) {\n    return res.status(422).json({\n      error: 'Validation failed',\n      details: errors\n    });\n  }\n});\n\n// 500 Internal Server Error - Server error\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({\n    error: 'Internal server error'\n  });\n});\n```\n\n**Java/Spring Boot:**\n```java\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    // 400 Bad Request - Invalid input\n    @PostMapping\n    public ResponseEntity<?> createUser(@Valid @RequestBody User user, BindingResult result) {\n        if (result.hasErrors()) {\n            return ResponseEntity.badRequest()\n                .body(new ErrorResponse(\"Validation failed\", result.getFieldErrors()));\n        }\n        User createdUser = userService.save(user);\n        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);\n    }\n    \n    // 401 Unauthorized - Authentication required\n    @GetMapping(\"/profile\")\n    @PreAuthorize(\"isAuthenticated()\")\n    public ResponseEntity<User> getProfile(Authentication auth) {\n        User user = userService.findByEmail(auth.getName());\n        return ResponseEntity.ok(user);\n    }\n    \n    // 403 Forbidden - Access denied\n    @DeleteMapping(\"/{id}\")\n    @PreAuthorize(\"hasRole('ADMIN') or @userService.isOwner(#id, authentication.name)\")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        userService.deleteById(id);\n        return ResponseEntity.noContent().build();\n    }\n    \n    // 404 Not Found - Resource doesn't exist\n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        return userService.findById(id)\n            .map(user -> ResponseEntity.ok(user))\n            .orElse(ResponseEntity.notFound().build());\n    }\n    \n    // 422 Unprocessable Entity - Validation failed\n    @PostMapping\n    public ResponseEntity<?> createUserWithValidation(@Valid @RequestBody User user, BindingResult result) {\n        if (result.hasErrors()) {\n            return ResponseEntity.unprocessableEntity()\n                .body(new ValidationErrorResponse(\"Validation failed\", result.getFieldErrors()));\n        }\n        User createdUser = userService.save(user);\n        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);\n    }\n}\n\n// Global Exception Handler\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleInternalServerError(Exception ex) {\n        log.error(\"Internal server error\", ex);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n            .body(new ErrorResponse(\"Internal server error\", null));\n    }\n}\n```\n\n## Request/Response Format\n\n### Consistent Response Structure\n\n```javascript\n// Success Response\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": 123,\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\"\n  },\n  \"message\": \"User created successfully\"\n}\n\n// Error Response\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Email is required\",\n    \"details\": [\n      {\n        \"field\": \"email\",\n        \"message\": \"Email is required\"\n      }\n    ]\n  }\n}\n```\n\n### Pagination\n\n```javascript\n// Request\nGET /api/users?page=1&limit=10&sort=name&order=asc\n\n// Response\n{\n  \"success\": true,\n  \"data\": [\n    // ... users array\n  ],\n  \"pagination\": {\n    \"page\": 1,\n    \"limit\": 10,\n    \"total\": 100,\n    \"pages\": 10,\n    \"hasNext\": true,\n    \"hasPrev\": false\n  }\n}\n```\n\n## Authentication & Authorization\n\n### JWT Implementation\n\n```javascript\nconst jwt = require('jsonwebtoken');\n\n// Generate token\nfunction generateToken(user) {\n  return jwt.sign(\n    { \n      id: user.id, \n      email: user.email,\n      role: user.role \n    },\n    process.env.JWT_SECRET,\n    { expiresIn: '24h' }\n  );\n}\n\n// Verify token\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({ error: 'Access token required' });\n  }\n\n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ error: 'Invalid token' });\n    }\n    req.user = user;\n    next();\n  });\n}\n```\n\n## API Versioning\n\n### URL Versioning\n\n```javascript\n// Version 1\napp.use('/api/v1/users', userRoutesV1);\n\n// Version 2\napp.use('/api/v2/users', userRoutesV2);\n```\n\n### Header Versioning\n\n```javascript\napp.use((req, res, next) => {\n  const version = req.headers['api-version'] || '1.0';\n  req.apiVersion = version;\n  next();\n});\n```\n\n## Rate Limiting\n\n```javascript\nconst rateLimit = require('express-rate-limit');\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: {\n    error: 'Too many requests from this IP, please try again later.'\n  }\n});\n\napp.use('/api/', limiter);\n```\n\n## Input Validation\n\n```javascript\nconst { body, validationResult } = require('express-validator');\n\nconst validateUser = [\n  body('email').isEmail().normalizeEmail(),\n  body('password').isLength({ min: 6 }),\n  body('name').trim().isLength({ min: 1 }),\n  (req, res, next) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(422).json({\n        error: 'Validation failed',\n        details: errors.array()\n      });\n    }\n    next();\n  }\n];\n\napp.post('/api/users', validateUser, createUser);\n```\n\n## Error Handling\n\n```javascript\nclass APIError extends Error {\n  constructor(message, statusCode, code) {\n    super(message);\n    this.statusCode = statusCode;\n    this.code = code;\n    this.isOperational = true;\n  }\n}\n\n// Global error handler\napp.use((err, req, res, next) => {\n  if (err instanceof APIError) {\n    return res.status(err.statusCode).json({\n      success: false,\n      error: {\n        code: err.code,\n        message: err.message\n      }\n    });\n  }\n\n  // Log unexpected errors\n  console.error(err.stack);\n  \n  res.status(500).json({\n    success: false,\n    error: {\n      code: 'INTERNAL_ERROR',\n      message: 'Internal server error'\n    }\n  });\n});\n```\n\n## Performance Optimization\n\n### Caching\n\n```javascript\nconst redis = require('redis');\nconst client = redis.createClient();\n\nasync function getCachedUser(userId) {\n  const cached = await client.get(`user:${userId}`);\n  if (cached) {\n    return JSON.parse(cached);\n  }\n  \n  const user = await getUserFromDB(userId);\n  await client.setex(`user:${userId}`, 3600, JSON.stringify(user));\n  return user;\n}\n```\n\n### Compression\n\n```javascript\nconst compression = require('compression');\napp.use(compression());\n```\n\n## Documentation\n\n### OpenAPI/Swagger\n\n```javascript\nconst swaggerJsdoc = require('swagger-jsdoc');\nconst swaggerUi = require('swagger-ui-express');\n\nconst options = {\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'User API',\n      version: '1.0.0',\n      description: 'A simple User API'\n    },\n    servers: [\n      {\n        url: 'http://localhost:3000/api',\n        description: 'Development server'\n      }\n    ]\n  },\n  apis: ['./routes/*.js']\n};\n\nconst specs = swaggerJsdoc(options);\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));\n```\n\n## Testing\n\n```javascript\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('User API', () => {\n  test('GET /api/users should return users', async () => {\n    const response = await request(app)\n      .get('/api/users')\n      .expect(200);\n    \n    expect(response.body.success).toBe(true);\n    expect(Array.isArray(response.body.data)).toBe(true);\n  });\n\n  test('POST /api/users should create user', async () => {\n    const userData = {\n      name: 'John Doe',\n      email: 'john@example.com',\n      password: 'password123'\n    };\n\n    const response = await request(app)\n      .post('/api/users')\n      .send(userData)\n      .expect(201);\n    \n    expect(response.body.success).toBe(true);\n    expect(response.body.data.email).toBe(userData.email);\n  });\n});\n```\n\n## Conclusion\n\nFollowing these REST API best practices will help you build robust, scalable, and maintainable APIs. Remember to:\n\n- Keep your APIs consistent\n- Use appropriate HTTP status codes\n- Implement proper error handling\n- Add authentication and authorization\n- Document your APIs\n- Test thoroughly\n- Monitor and optimize performance\n\nThese practices will make your APIs more reliable and easier to use for frontend developers and API consumers."
}
