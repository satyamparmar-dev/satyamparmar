{
  "title": "Advanced Node.js Design Patterns",
  "slug": "advanced-nodejs-patterns",
  "date": "2025-01-20",
  "author": "Pass Gen",
  "tags": ["Backend Engineering", "Node.js", "Design Patterns", "Architecture"],
  "excerpt": "Master advanced design patterns in Node.js including Observer, Factory, Singleton, and Dependency Injection patterns for scalable applications.",
  "content": "# Advanced Node.js Design Patterns\n\nDesign patterns are essential building blocks for creating maintainable, scalable Node.js applications. This comprehensive guide explores advanced patterns that every backend engineer should master.\n\n## Observer Pattern\n\nThe Observer pattern allows objects to notify multiple observers about state changes.\n\n```javascript\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n  }\n\n  emit(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach(listener => listener(data));\n    }\n  }\n}\n\n// Usage\nconst emitter = new EventEmitter();\nemitter.on('user:created', (user) => {\n  console.log('New user created:', user.email);\n});\n```\n\n## Factory Pattern\n\nCreate objects without specifying their exact class.\n\n```javascript\nclass DatabaseConnection {\n  static create(type) {\n    switch (type) {\n      case 'mysql':\n        return new MySQLConnection();\n      case 'postgresql':\n        return new PostgreSQLConnection();\n      case 'mongodb':\n        return new MongoDBConnection();\n      default:\n        throw new Error('Unsupported database type');\n    }\n  }\n}\n\n// Usage\nconst db = DatabaseConnection.create('postgresql');\n```\n\n## Singleton Pattern\n\nEnsure only one instance of a class exists.\n\n```javascript\nclass Logger {\n  constructor() {\n    if (Logger.instance) {\n      return Logger.instance;\n    }\n    \n    this.logs = [];\n    Logger.instance = this;\n  }\n\n  log(message) {\n    this.logs.push({ message, timestamp: new Date() });\n    console.log(message);\n  }\n}\n\n// Usage\nconst logger1 = new Logger();\nconst logger2 = new Logger();\nconsole.log(logger1 === logger2); // true\n```\n\n## Dependency Injection\n\nInject dependencies rather than hard-coding them.\n\n```javascript\nclass UserService {\n  constructor(userRepository, emailService) {\n    this.userRepository = userRepository;\n    this.emailService = emailService;\n  }\n\n  async createUser(userData) {\n    const user = await this.userRepository.save(userData);\n    await this.emailService.sendWelcomeEmail(user.email);\n    return user;\n  }\n}\n\n// Usage\nconst userService = new UserService(\n  new UserRepository(),\n  new EmailService()\n);\n```\n\n## Middleware Pattern\n\nChain multiple functions to process requests.\n\n```javascript\nclass MiddlewareManager {\n  constructor() {\n    this.middlewares = [];\n  }\n\n  use(middleware) {\n    this.middlewares.push(middleware);\n  }\n\n  async execute(context) {\n    let index = 0;\n    \n    const next = async () => {\n      if (index < this.middlewares.length) {\n        const middleware = this.middlewares[index++];\n        await middleware(context, next);\n      }\n    };\n    \n    await next();\n  }\n}\n\n// Usage\nconst manager = new MiddlewareManager();\nmanager.use(async (ctx, next) => {\n  console.log('Before processing');\n  await next();\n  console.log('After processing');\n});\n```\n\n## Strategy Pattern\n\nDefine a family of algorithms and make them interchangeable.\n\n```javascript\nclass PaymentProcessor {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n\n  processPayment(amount) {\n    return this.strategy.process(amount);\n  }\n}\n\nclass CreditCardStrategy {\n  process(amount) {\n    return `Processing $${amount} via Credit Card`;\n  }\n}\n\nclass PayPalStrategy {\n  process(amount) {\n    return `Processing $${amount} via PayPal`;\n  }\n}\n\n// Usage\nconst processor = new PaymentProcessor(new CreditCardStrategy());\nprocessor.processPayment(100);\n```\n\n## Best Practices\n\n1. **Choose patterns wisely** - Don't over-engineer simple solutions\n2. **Keep it simple** - Start with basic patterns and evolve\n3. **Test thoroughly** - Patterns can make testing more complex\n4. **Document decisions** - Explain why specific patterns were chosen\n5. **Refactor regularly** - Patterns should evolve with requirements\n\n## Conclusion\n\nMastering these design patterns will make you a more effective Node.js developer. Start implementing them in your projects and watch your code become more maintainable and scalable.\n\nRemember: Patterns are tools, not rules. Use them when they solve real problems, not just because they're popular."
}
