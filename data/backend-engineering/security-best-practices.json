{
  "title": "Backend Security Best Practices",
  "slug": "backend-security-best-practices",
  "date": "2025-01-14",
  "author": "Pass Gen",
  "tags": ["Backend Engineering", "Security", "Authentication", "Authorization"],
  "excerpt": "Essential security practices for backend engineers including authentication, authorization, input validation, encryption, and vulnerability prevention.",
  "content": "# Backend Security Best Practices\n\nSecurity is paramount in backend development. This comprehensive guide covers essential security practices to protect your applications from common vulnerabilities and attacks.\n\n## Authentication & Authorization\n\n### JWT Implementation\n\n```javascript\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\n\n// Secure password hashing\nasync function hashPassword(password) {\n  const saltRounds = 12;\n  return await bcrypt.hash(password, saltRounds);\n}\n\n// Verify password\nasync function verifyPassword(password, hash) {\n  return await bcrypt.compare(password, hash);\n}\n\n// Generate secure JWT\nfunction generateToken(user) {\n  const payload = {\n    id: user.id,\n    email: user.email,\n    role: user.role\n  };\n  \n  return jwt.sign(payload, process.env.JWT_SECRET, {\n    expiresIn: '15m', // Short expiration\n    issuer: 'your-app',\n    audience: 'your-app-users'\n  });\n}\n\n// Generate refresh token\nfunction generateRefreshToken(user) {\n  return jwt.sign(\n    { id: user.id, type: 'refresh' },\n    process.env.REFRESH_SECRET,\n    { expiresIn: '7d' }\n  );\n}\n```\n\n### Role-Based Access Control (RBAC)\n\n```javascript\n// Define roles and permissions\nconst ROLES = {\n  ADMIN: 'admin',\n  USER: 'user',\n  MODERATOR: 'moderator'\n};\n\nconst PERMISSIONS = {\n  READ_USERS: 'read:users',\n  WRITE_USERS: 'write:users',\n  DELETE_USERS: 'delete:users',\n  READ_ORDERS: 'read:orders',\n  WRITE_ORDERS: 'write:orders'\n};\n\nconst ROLE_PERMISSIONS = {\n  [ROLES.ADMIN]: [\n    PERMISSIONS.READ_USERS,\n    PERMISSIONS.WRITE_USERS,\n    PERMISSIONS.DELETE_USERS,\n    PERMISSIONS.READ_ORDERS,\n    PERMISSIONS.WRITE_ORDERS\n  ],\n  [ROLES.USER]: [\n    PERMISSIONS.READ_ORDERS,\n    PERMISSIONS.WRITE_ORDERS\n  ]\n};\n\n// Middleware to check permissions\nfunction requirePermission(permission) {\n  return (req, res, next) => {\n    const userRole = req.user.role;\n    const userPermissions = ROLE_PERMISSIONS[userRole] || [];\n    \n    if (!userPermissions.includes(permission)) {\n      return res.status(403).json({\n        error: 'Insufficient permissions'\n      });\n    }\n    \n    next();\n  };\n}\n\n// Usage\napp.get('/api/users', \n  authenticateToken,\n  requirePermission(PERMISSIONS.READ_USERS),\n  getUsers\n);\n```\n\n## Input Validation & Sanitization\n\n### Express Validator\n\n```javascript\nconst { body, param, query, validationResult } = require('express-validator');\nconst { sanitize } = require('express-validator');\n\n// User registration validation\nconst validateUserRegistration = [\n  body('email')\n    .isEmail()\n    .normalizeEmail()\n    .withMessage('Valid email is required'),\n  \n  body('password')\n    .isLength({ min: 8 })\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/)\n    .withMessage('Password must be at least 8 characters with uppercase, lowercase, number and special character'),\n  \n  body('name')\n    .trim()\n    .isLength({ min: 2, max: 50 })\n    .matches(/^[a-zA-Z\\s]+$/)\n    .withMessage('Name must be 2-50 characters, letters only'),\n  \n  body('age')\n    .optional()\n    .isInt({ min: 13, max: 120 })\n    .withMessage('Age must be between 13 and 120'),\n  \n  // Sanitize inputs\n  sanitize('email').trim().toLowerCase(),\n  sanitize('name').trim(),\n  \n  // Handle validation errors\n  (req, res, next) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({\n        error: 'Validation failed',\n        details: errors.array()\n      });\n    }\n    next();\n  }\n];\n```\n\n### SQL Injection Prevention\n\n```javascript\n// Use parameterized queries\nasync function getUserById(id) {\n  // Good: Parameterized query\n  const query = 'SELECT * FROM users WHERE id = $1';\n  const result = await pool.query(query, [id]);\n  return result.rows[0];\n}\n\n// Bad: String concatenation (vulnerable to SQL injection)\n// const query = `SELECT * FROM users WHERE id = ${id}`;\n\n// For dynamic queries, use query builder\nconst { Pool } = require('pg');\nconst { QueryBuilder } = require('knex');\n\nconst db = require('knex')({\n  client: 'postgresql',\n  connection: process.env.DATABASE_URL\n});\n\n// Safe dynamic query building\nasync function searchUsers(filters) {\n  let query = db('users').select('*');\n  \n  if (filters.name) {\n    query = query.where('name', 'ilike', `%${filters.name}%`);\n  }\n  \n  if (filters.email) {\n    query = query.where('email', 'ilike', `%${filters.email}%`);\n  }\n  \n  if (filters.status) {\n    query = query.where('status', filters.status);\n  }\n  \n  return await query;\n}\n```\n\n## Rate Limiting & DDoS Protection\n\n### Express Rate Limiting\n\n```javascript\nconst rateLimit = require('express-rate-limit');\nconst slowDown = require('express-slow-down');\n\n// General rate limiting\nconst generalLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: {\n    error: 'Too many requests from this IP, please try again later.'\n  },\n  standardHeaders: true,\n  legacyHeaders: false\n});\n\n// Strict rate limiting for auth endpoints\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // limit each IP to 5 requests per windowMs\n  skipSuccessfulRequests: true,\n  message: {\n    error: 'Too many authentication attempts, please try again later.'\n  }\n});\n\n// Slow down repeated requests\nconst speedLimiter = slowDown({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  delayAfter: 2, // allow 2 requests per 15 minutes, then...\n  delayMs: 500 // begin adding 500ms of delay per request above 2\n});\n\n// Apply rate limiting\napp.use('/api/', generalLimiter);\napp.use('/api/auth/', authLimiter);\napp.use('/api/', speedLimiter);\n```\n\n### Advanced Rate Limiting\n\n```javascript\nconst RedisStore = require('rate-limit-redis');\nconst redis = require('redis');\n\nconst client = redis.createClient({\n  host: process.env.REDIS_HOST,\n  port: process.env.REDIS_PORT\n});\n\n// Redis-based rate limiting for distributed systems\nconst redisLimiter = rateLimit({\n  store: new RedisStore({\n    sendCommand: (...args) => client.sendCommand(args)\n  }),\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  keyGenerator: (req) => {\n    // Custom key generation\n    return `${req.ip}:${req.user?.id || 'anonymous'}`;\n  }\n});\n```\n\n## Data Encryption\n\n### Sensitive Data Encryption\n\n```javascript\nconst crypto = require('crypto');\n\nclass EncryptionService {\n  constructor() {\n    this.algorithm = 'aes-256-gcm';\n    this.key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');\n  }\n  \n  encrypt(text) {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipher(this.algorithm, this.key);\n    cipher.setAAD(Buffer.from('additional-data'));\n    \n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return {\n      encrypted,\n      iv: iv.toString('hex'),\n      authTag: authTag.toString('hex')\n    };\n  }\n  \n  decrypt(encryptedData) {\n    const decipher = crypto.createDecipher(\n      this.algorithm, \n      this.key\n    );\n    \n    decipher.setAAD(Buffer.from('additional-data'));\n    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));\n    \n    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  }\n}\n\n// Usage\nconst encryptionService = new EncryptionService();\n\n// Encrypt sensitive data before storing\nconst encryptedSSN = encryptionService.encrypt(user.ssn);\nawait db.query(\n  'INSERT INTO users (ssn_encrypted, ssn_iv, ssn_auth_tag) VALUES ($1, $2, $3)',\n  [encryptedSSN.encrypted, encryptedSSN.iv, encryptedSSN.authTag]\n);\n```\n\n## Security Headers\n\n### Helmet.js Configuration\n\n```javascript\nconst helmet = require('helmet');\n\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n    },\n  },\n  crossOriginEmbedderPolicy: false,\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  }\n}));\n\n// Additional security headers\napp.use((req, res, next) => {\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');\n  next();\n});\n```\n\n## CORS Configuration\n\n```javascript\nconst cors = require('cors');\n\nconst corsOptions = {\n  origin: function (origin, callback) {\n    // Allow requests with no origin (mobile apps, Postman, etc.)\n    if (!origin) return callback(null, true);\n    \n    const allowedOrigins = [\n      'https://yourdomain.com',\n      'https://www.yourdomain.com',\n      'https://staging.yourdomain.com'\n    ];\n    \n    if (allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true,\n  optionsSuccessStatus: 200,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']\n};\n\napp.use(cors(corsOptions));\n```\n\n## Logging & Monitoring\n\n### Security Event Logging\n\n```javascript\nconst winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  transports: [\n    new winston.transports.File({ filename: 'security.log' }),\n    new winston.transports.Console()\n  ]\n});\n\n// Log security events\nfunction logSecurityEvent(event, details) {\n  logger.warn('Security Event', {\n    event,\n    details,\n    timestamp: new Date().toISOString(),\n    ip: details.ip,\n    userAgent: details.userAgent\n  });\n}\n\n// Usage\napp.post('/api/auth/login', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await findUserByEmail(email);\n    \n    if (!user) {\n      logSecurityEvent('LOGIN_FAILED', {\n        email,\n        ip: req.ip,\n        userAgent: req.get('User-Agent')\n      });\n      \n      return res.status(401).json({\n        error: 'Invalid credentials'\n      });\n    }\n    \n    // ... rest of login logic\n  } catch (error) {\n    logSecurityEvent('LOGIN_ERROR', {\n      error: error.message,\n      ip: req.ip\n    });\n    \n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n```\n\n## Environment Security\n\n### Secure Environment Configuration\n\n```javascript\n// .env.example\n/*\nNODE_ENV=production\nPORT=3000\n\n# Database\nDATABASE_URL=postgresql://user:password@localhost:5432/dbname\n\n# JWT\nJWT_SECRET=your-super-secret-jwt-key-here\nREFRESH_SECRET=your-super-secret-refresh-key-here\n\n# Encryption\nENCRYPTION_KEY=your-32-character-hex-encryption-key\n\n# Redis\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_PASSWORD=your-redis-password\n\n# External APIs\nAPI_KEY=your-api-key\nAPI_SECRET=your-api-secret\n*/\n\n// Validate required environment variables\nconst requiredEnvVars = [\n  'NODE_ENV',\n  'DATABASE_URL',\n  'JWT_SECRET',\n  'REFRESH_SECRET',\n  'ENCRYPTION_KEY'\n];\n\nfunction validateEnvironment() {\n  const missing = requiredEnvVars.filter(envVar => !process.env[envVar]);\n  \n  if (missing.length > 0) {\n    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);\n  }\n  \n  // Validate JWT secret strength\n  if (process.env.JWT_SECRET.length < 32) {\n    throw new Error('JWT_SECRET must be at least 32 characters long');\n  }\n}\n\nvalidateEnvironment();\n```\n\n## API Security Testing\n\n### Automated Security Tests\n\n```javascript\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('Security Tests', () => {\n  test('should reject requests without authentication', async () => {\n    const response = await request(app)\n      .get('/api/users')\n      .expect(401);\n    \n    expect(response.body.error).toBe('Access token required');\n  });\n  \n  test('should reject invalid JWT tokens', async () => {\n    const response = await request(app)\n      .get('/api/users')\n      .set('Authorization', 'Bearer invalid-token')\n      .expect(403);\n    \n    expect(response.body.error).toBe('Invalid token');\n  });\n  \n  test('should prevent SQL injection', async () => {\n    const maliciousInput = \"'; DROP TABLE users; --\";\n    \n    const response = await request(app)\n      .get(`/api/users?search=${maliciousInput}`)\n      .set('Authorization', 'Bearer valid-token')\n      .expect(200);\n    \n    // Should not crash or return unexpected data\n    expect(response.body.success).toBe(true);\n  });\n  \n  test('should enforce rate limiting', async () => {\n    const promises = [];\n    \n    // Make 10 requests quickly\n    for (let i = 0; i < 10; i++) {\n      promises.push(\n        request(app)\n          .post('/api/auth/login')\n          .send({ email: 'test@example.com', password: 'wrong' })\n      );\n    }\n    \n    const responses = await Promise.all(promises);\n    \n    // Some requests should be rate limited\n    const rateLimitedResponses = responses.filter(\n      res => res.status === 429\n    );\n    \n    expect(rateLimitedResponses.length).toBeGreaterThan(0);\n  });\n});\n```\n\n## Conclusion\n\nSecurity is not a one-time implementation but an ongoing process. Key takeaways:\n\n1. **Always validate and sanitize input**\n2. **Use parameterized queries** to prevent SQL injection\n3. **Implement proper authentication and authorization**\n4. **Use HTTPS everywhere**\n5. **Set security headers**\n6. **Implement rate limiting**\n7. **Log security events**\n8. **Keep dependencies updated**\n9. **Regular security audits**\n10. **Follow the principle of least privilege**\n\nRemember: Security is everyone's responsibility, and it's better to be proactive than reactive when it comes to protecting your application and users' data."
}
