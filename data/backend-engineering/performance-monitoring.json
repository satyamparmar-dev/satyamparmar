{
  "title": "Backend Performance Monitoring & Optimization",
  "slug": "backend-performance-monitoring",
  "date": "2025-01-12",
  "author": "Pass Gen",
  "tags": ["Backend Engineering", "Performance", "Monitoring", "Optimization"],
  "excerpt": "Comprehensive guide to monitoring backend performance, identifying bottlenecks, and implementing optimization strategies for scalable applications.",
  "content": "# Backend Performance Monitoring & Optimization\n\nPerformance monitoring is crucial for maintaining scalable, responsive backend applications. This guide covers essential monitoring techniques, tools, and optimization strategies.\n\n## Performance Metrics to Track\n\n### Key Performance Indicators (KPIs)\n\n```javascript\n// Core performance metrics\nconst performanceMetrics = {\n  // Response time metrics\n  responseTime: {\n    p50: 0,    // 50th percentile\n    p95: 0,    // 95th percentile\n    p99: 0,    // 99th percentile\n    max: 0     // Maximum response time\n  },\n  \n  // Throughput metrics\n  throughput: {\n    requestsPerSecond: 0,\n    requestsPerMinute: 0,\n    concurrentUsers: 0\n  },\n  \n  // Error metrics\n  errors: {\n    errorRate: 0,        // Percentage of failed requests\n    errorCount: 0,       // Total error count\n    errorTypes: {}       // Breakdown by error type\n  },\n  \n  // Resource utilization\n  resources: {\n    cpuUsage: 0,         // CPU utilization percentage\n    memoryUsage: 0,      // Memory usage in MB\n    diskUsage: 0,        // Disk usage percentage\n    networkIO: 0         // Network I/O in bytes\n  }\n};\n```\n\n### Custom Performance Monitoring\n\n```javascript\nclass PerformanceMonitor {\n  constructor() {\n    this.metrics = new Map();\n    this.startTimes = new Map();\n  }\n  \n  // Start timing an operation\n  startTimer(operationId) {\n    this.startTimes.set(operationId, process.hrtime.bigint());\n  }\n  \n  // End timing and record metric\n  endTimer(operationId, tags = {}) {\n    const startTime = this.startTimes.get(operationId);\n    if (!startTime) return;\n    \n    const endTime = process.hrtime.bigint();\n    const duration = Number(endTime - startTime) / 1000000; // Convert to milliseconds\n    \n    this.recordMetric('operation_duration', duration, {\n      operation: operationId,\n      ...tags\n    });\n    \n    this.startTimes.delete(operationId);\n  }\n  \n  // Record a metric value\n  recordMetric(name, value, tags = {}) {\n    const key = `${name}_${JSON.stringify(tags)}`;\n    \n    if (!this.metrics.has(key)) {\n      this.metrics.set(key, {\n        name,\n        tags,\n        values: [],\n        count: 0,\n        sum: 0,\n        min: Infinity,\n        max: -Infinity\n      });\n    }\n    \n    const metric = this.metrics.get(key);\n    metric.values.push(value);\n    metric.count++;\n    metric.sum += value;\n    metric.min = Math.min(metric.min, value);\n    metric.max = Math.max(metric.max, value);\n    \n    // Keep only last 1000 values to prevent memory leaks\n    if (metric.values.length > 1000) {\n      metric.values = metric.values.slice(-1000);\n    }\n  }\n  \n  // Get percentile value\n  getPercentile(values, percentile) {\n    const sorted = [...values].sort((a, b) => a - b);\n    const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n    return sorted[index] || 0;\n  }\n  \n  // Get metrics summary\n  getMetricsSummary() {\n    const summary = {};\n    \n    for (const [key, metric] of this.metrics) {\n      if (metric.count === 0) continue;\n      \n      summary[metric.name] = {\n        count: metric.count,\n        sum: metric.sum,\n        avg: metric.sum / metric.count,\n        min: metric.min,\n        max: metric.max,\n        p50: this.getPercentile(metric.values, 50),\n        p95: this.getPercentile(metric.values, 95),\n        p99: this.getPercentile(metric.values, 99),\n        tags: metric.tags\n      };\n    }\n    \n    return summary;\n  }\n}\n\n// Global performance monitor instance\nconst perfMonitor = new PerformanceMonitor();\n```\n\n## Application Performance Monitoring (APM)\n\n### Express.js Middleware for Request Tracking\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// Request timing middleware\napp.use((req, res, next) => {\n  const requestId = `${req.method}_${req.path}_${Date.now()}`;\n  req.requestId = requestId;\n  \n  perfMonitor.startTimer(requestId);\n  \n  // Override res.end to capture response time\n  const originalEnd = res.end;\n  res.end = function(...args) {\n    perfMonitor.endTimer(requestId, {\n      method: req.method,\n      path: req.path,\n      statusCode: res.statusCode\n    });\n    \n    originalEnd.apply(this, args);\n  };\n  \n  next();\n});\n\n// Database query monitoring\nfunction monitorDatabaseQuery(query, params) {\n  const queryId = `db_query_${Date.now()}`;\n  perfMonitor.startTimer(queryId);\n  \n  return query.then(result => {\n    perfMonitor.endTimer(queryId, {\n      type: 'database',\n      query: query.sql || 'unknown'\n    });\n    return result;\n  }).catch(error => {\n    perfMonitor.endTimer(queryId, {\n      type: 'database',\n      query: query.sql || 'unknown',\n      error: true\n    });\n    throw error;\n  });\n}\n\n// Usage example\napp.get('/api/users', async (req, res) => {\n  try {\n    const users = await monitorDatabaseQuery(\n      db.query('SELECT * FROM users')\n    );\n    \n    res.json(users);\n  } catch (error) {\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n```\n\n### Memory and CPU Monitoring\n\n```javascript\nconst os = require('os');\nconst process = require('process');\n\nclass SystemMonitor {\n  constructor() {\n    this.startTime = Date.now();\n    this.startCpuUsage = process.cpuUsage();\n  }\n  \n  getSystemMetrics() {\n    const memUsage = process.memoryUsage();\n    const cpuUsage = process.cpuUsage(this.startCpuUsage);\n    \n    return {\n      // Memory metrics\n      memory: {\n        rss: Math.round(memUsage.rss / 1024 / 1024), // MB\n        heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),\n        heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),\n        external: Math.round(memUsage.external / 1024 / 1024),\n        systemTotal: Math.round(os.totalmem() / 1024 / 1024),\n        systemFree: Math.round(os.freemem() / 1024 / 1024)\n      },\n      \n      // CPU metrics\n      cpu: {\n        user: cpuUsage.user / 1000000, // Convert to seconds\n        system: cpuUsage.system / 1000000,\n        cores: os.cpus().length,\n        loadAverage: os.loadavg()\n      },\n      \n      // Process metrics\n      process: {\n        uptime: Math.round((Date.now() - this.startTime) / 1000),\n        pid: process.pid,\n        version: process.version,\n        platform: process.platform\n      }\n    };\n  }\n  \n  // Check if system is under stress\n  isSystemStressed() {\n    const metrics = this.getSystemMetrics();\n    const loadAvg = metrics.cpu.loadAverage[0];\n    const memoryUsagePercent = (metrics.memory.heapUsed / metrics.memory.heapTotal) * 100;\n    \n    return {\n      highLoad: loadAvg > os.cpus().length * 0.8,\n      highMemory: memoryUsagePercent > 80,\n      lowMemory: metrics.memory.systemFree < 100 // Less than 100MB free\n    };\n  }\n}\n\nconst systemMonitor = new SystemMonitor();\n\n// Periodic system monitoring\nsetInterval(() => {\n  const metrics = systemMonitor.getSystemMetrics();\n  const stress = systemMonitor.isSystemStressed();\n  \n  // Log metrics every 30 seconds\n  console.log('System Metrics:', {\n    memory: metrics.memory,\n    cpu: metrics.cpu,\n    stress\n  });\n  \n  // Alert on high stress\n  if (stress.highLoad || stress.highMemory || stress.lowMemory) {\n    console.warn('System under stress:', stress);\n  }\n}, 30000);\n```\n\n## Database Performance Monitoring\n\n### Query Performance Tracking\n\n```javascript\nconst { Pool } = require('pg');\n\nclass MonitoredPool extends Pool {\n  constructor(config) {\n    super(config);\n    this.queryCount = 0;\n    this.slowQueries = [];\n    this.queryTimes = [];\n  }\n  \n  async query(text, params) {\n    const startTime = process.hrtime.bigint();\n    this.queryCount++;\n    \n    try {\n      const result = await super.query(text, params);\n      const endTime = process.hrtime.bigint();\n      const duration = Number(endTime - startTime) / 1000000; // Convert to ms\n      \n      // Record query performance\n      this.queryTimes.push(duration);\n      \n      // Track slow queries\n      if (duration > 1000) { // Queries slower than 1 second\n        this.slowQueries.push({\n          query: text,\n          params,\n          duration,\n          timestamp: new Date()\n        });\n        \n        console.warn(`Slow query detected: ${duration}ms`, {\n          query: text.substring(0, 100) + '...',\n          params\n        });\n      }\n      \n      return result;\n    } catch (error) {\n      const endTime = process.hrtime.bigint();\n      const duration = Number(endTime - startTime) / 1000000;\n      \n      console.error('Database query error:', {\n        query: text,\n        params,\n        duration,\n        error: error.message\n      });\n      \n      throw error;\n    }\n  }\n  \n  getQueryStats() {\n    const avgTime = this.queryTimes.length > 0 \n      ? this.queryTimes.reduce((a, b) => a + b, 0) / this.queryTimes.length \n      : 0;\n    \n    return {\n      totalQueries: this.queryCount,\n      averageQueryTime: Math.round(avgTime),\n      slowQueries: this.slowQueries.length,\n      recentSlowQueries: this.slowQueries.slice(-10)\n    };\n  }\n}\n\n// Use monitored pool\nconst pool = new MonitoredPool({\n  connectionString: process.env.DATABASE_URL\n});\n\n// Log query stats every minute\nsetInterval(() => {\n  const stats = pool.getQueryStats();\n  console.log('Database Performance:', stats);\n}, 60000);\n```\n\n## Real-time Monitoring Dashboard\n\n### Express.js Health Check Endpoint\n\n```javascript\napp.get('/health', (req, res) => {\n  const systemMetrics = systemMonitor.getSystemMetrics();\n  const performanceMetrics = perfMonitor.getMetricsSummary();\n  const dbStats = pool.getQueryStats();\n  const stress = systemMonitor.isSystemStressed();\n  \n  const health = {\n    status: stress.highLoad || stress.highMemory ? 'degraded' : 'healthy',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n    system: systemMetrics,\n    performance: performanceMetrics,\n    database: dbStats,\n    alerts: {\n      highLoad: stress.highLoad,\n      highMemory: stress.highMemory,\n      lowMemory: stress.lowMemory\n    }\n  };\n  \n  const statusCode = health.status === 'healthy' ? 200 : 503;\n  res.status(statusCode).json(health);\n});\n\n// Detailed metrics endpoint\napp.get('/metrics', (req, res) => {\n  const metrics = {\n    performance: perfMonitor.getMetricsSummary(),\n    system: systemMonitor.getSystemMetrics(),\n    database: pool.getQueryStats()\n  };\n  \n  res.json(metrics);\n});\n```\n\n## Performance Optimization Strategies\n\n### Caching Implementation\n\n```javascript\nconst NodeCache = require('node-cache');\nconst Redis = require('redis');\n\nclass CacheManager {\n  constructor() {\n    this.memoryCache = new NodeCache({ stdTTL: 600 }); // 10 minutes\n    this.redis = Redis.createClient({\n      host: process.env.REDIS_HOST,\n      port: process.env.REDIS_PORT\n    });\n  }\n  \n  async get(key) {\n    // Try memory cache first\n    let value = this.memoryCache.get(key);\n    if (value) {\n      perfMonitor.recordMetric('cache_hit', 1, { type: 'memory' });\n      return value;\n    }\n    \n    // Try Redis cache\n    try {\n      const redisValue = await this.redis.get(key);\n      if (redisValue) {\n        const parsed = JSON.parse(redisValue);\n        this.memoryCache.set(key, parsed); // Populate memory cache\n        perfMonitor.recordMetric('cache_hit', 1, { type: 'redis' });\n        return parsed;\n      }\n    } catch (error) {\n      console.error('Redis cache error:', error);\n    }\n    \n    perfMonitor.recordMetric('cache_miss', 1, { type: 'all' });\n    return null;\n  }\n  \n  async set(key, value, ttl = 3600) {\n    // Set in memory cache\n    this.memoryCache.set(key, value);\n    \n    // Set in Redis cache\n    try {\n      await this.redis.setex(key, ttl, JSON.stringify(value));\n    } catch (error) {\n      console.error('Redis cache set error:', error);\n    }\n  }\n  \n  async del(key) {\n    this.memoryCache.del(key);\n    try {\n      await this.redis.del(key);\n    } catch (error) {\n      console.error('Redis cache delete error:', error);\n    }\n  }\n}\n\nconst cache = new CacheManager();\n\n// Cached database query\nasync function getCachedUser(userId) {\n  const cacheKey = `user:${userId}`;\n  \n  let user = await cache.get(cacheKey);\n  if (user) {\n    return user;\n  }\n  \n  // Fetch from database\n  const result = await pool.query('SELECT * FROM users WHERE id = $1', [userId]);\n  user = result.rows[0];\n  \n  if (user) {\n    await cache.set(cacheKey, user, 1800); // 30 minutes\n  }\n  \n  return user;\n}\n```\n\n### Connection Pooling Optimization\n\n```javascript\n// Optimized database connection pool\nconst optimizedPool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  max: 20, // Maximum number of clients in the pool\n  min: 5,  // Minimum number of clients in the pool\n  idleTimeoutMillis: 30000, // Close idle clients after 30 seconds\n  connectionTimeoutMillis: 2000, // Return an error after 2 seconds\n  acquireTimeoutMillis: 30000, // Return an error after 30 seconds\n  createTimeoutMillis: 30000,\n  destroyTimeoutMillis: 5000,\n  reapIntervalMillis: 1000,\n  createRetryIntervalMillis: 200,\n  // SSL configuration for production\n  ssl: process.env.NODE_ENV === 'production' ? {\n    rejectUnauthorized: false\n  } : false\n});\n\n// Pool monitoring\nsetInterval(() => {\n  const poolStats = {\n    totalCount: optimizedPool.totalCount,\n    idleCount: optimizedPool.idleCount,\n    waitingCount: optimizedPool.waitingCount\n  };\n  \n  console.log('Pool Stats:', poolStats);\n  \n  // Alert if pool is exhausted\n  if (poolStats.waitingCount > 5) {\n    console.warn('High connection pool wait time!');\n  }\n}, 30000);\n```\n\n## Alerting and Notifications\n\n### Performance Alert System\n\n```javascript\nclass AlertManager {\n  constructor() {\n    this.alerts = new Map();\n    this.thresholds = {\n      responseTime: 2000, // 2 seconds\n      errorRate: 0.05,    // 5%\n      memoryUsage: 0.8,   // 80%\n      cpuUsage: 0.8       // 80%\n    };\n  }\n  \n  checkAlerts(metrics) {\n    const alerts = [];\n    \n    // Response time alert\n    if (metrics.performance?.operation_duration?.p95 > this.thresholds.responseTime) {\n      alerts.push({\n        type: 'HIGH_RESPONSE_TIME',\n        message: `95th percentile response time is ${metrics.performance.operation_duration.p95}ms`,\n        severity: 'warning'\n      });\n    }\n    \n    // Error rate alert\n    const errorRate = metrics.errors?.errorRate || 0;\n    if (errorRate > this.thresholds.errorRate) {\n      alerts.push({\n        type: 'HIGH_ERROR_RATE',\n        message: `Error rate is ${(errorRate * 100).toFixed(2)}%`,\n        severity: 'critical'\n      });\n    }\n    \n    // Memory usage alert\n    const memoryUsage = metrics.system?.memory?.heapUsed / metrics.system?.memory?.heapTotal || 0;\n    if (memoryUsage > this.thresholds.memoryUsage) {\n      alerts.push({\n        type: 'HIGH_MEMORY_USAGE',\n        message: `Memory usage is ${(memoryUsage * 100).toFixed(2)}%`,\n        severity: 'warning'\n      });\n    }\n    \n    return alerts;\n  }\n  \n  async sendAlert(alert) {\n    // Send to monitoring service (e.g., DataDog, New Relic, etc.)\n    console.warn('ALERT:', alert);\n    \n    // You can integrate with external services here\n    // await sendToSlack(alert);\n    // await sendToEmail(alert);\n  }\n}\n\nconst alertManager = new AlertManager();\n\n// Check alerts every 30 seconds\nsetInterval(() => {\n  const metrics = {\n    performance: perfMonitor.getMetricsSummary(),\n    system: systemMonitor.getSystemMetrics(),\n    errors: { errorRate: 0 } // Calculate from your error tracking\n  };\n  \n  const alerts = alertManager.checkAlerts(metrics);\n  alerts.forEach(alert => alertManager.sendAlert(alert));\n}, 30000);\n```\n\n## Conclusion\n\nEffective performance monitoring requires:\n\n1. **Comprehensive metrics collection** - Track all relevant KPIs\n2. **Real-time monitoring** - Detect issues as they happen\n3. **Proactive alerting** - Get notified before problems escalate\n4. **Performance optimization** - Continuously improve based on data\n5. **Regular analysis** - Review trends and patterns\n\nRemember: Monitoring without action is just data collection. Use the insights to continuously improve your application's performance and reliability."
}
