{
  "title": "Real-World Distributed Transactions & Saga Pattern Scenarios",
  "slug": "distributed-transactions-saga-scenarios",
  "date": "2025-01-20",
  "author": "Satyam Parmar",
  "tags": [
    "Backend Engineering",
    "Microservices",
    "Distributed Systems",
    "Saga",
    "Transactions",
    "Event Driven",
    "Kafka",
    "Idempotency",
    "Outbox",
    "Exactly Once",
    "Consistency",
    "Reconciliation",
    "DLQ"
  ],
  "excerpt": "Scenario-driven guide to distributed transactions in microservices: Saga orchestration vs choreography, compensations, idempotency, outbox, deduplication, retries, rollbacks, and ensuring eventual consistency.",
  "content": "# Real-World Distributed Transactions & Saga Pattern Scenarios (Java Edition)\n\nThis is a step-by-step guide that teaches distributed transactions and Sagas the way a senior architect would explain to a new engineer. We keep the language simple and show concrete Java code for every idea.\n\n---\n\n## 1️⃣ Payment succeeded, inventory failed — how to keep data consistent?\n\n### Problem (plain words)\nOrder → Payment → Inventory. Payment captured successfully. Inventory reservation failed. We must not leave the system in a half-done state.\n\n### Why Saga, not a global transaction?\n- Global (XA/2PC) locks are fragile and slow in distributed systems.\n- Sagas use local transactions per service and “undo” steps (compensations) if something downstream fails.\n\n### How it works (orchestrated Saga)\n1. Create order as PENDING.\n2. Capture payment.\n3. Reserve inventory.\n4. If inventory fails, refund payment and cancel order.\n\n### Orchestrator state (mental model)\nPENDING → PAID → RESERVED → CONFIRMED\n            ↘ (if fail) REFUNDING → CANCELLED\n\n### Java code — Order Orchestrator (Spring Boot style)\n```java\n@Service\n@RequiredArgsConstructor\npublic class OrderSagaOrchestrator {\n  private final PaymentClient paymentClient;\n  private final InventoryClient inventoryClient;\n  private final OrderRepository orderRepo;\n  private final SagaStepLogRepository stepLogRepo;\n\n  @Transactional\n  public void startSaga(UUID orderId) {\n    Order order = orderRepo.findById(orderId).orElseThrow();\n    logStep(orderId, \"CreateOrder\", \"DONE\");\n\n    try {\n      paymentClient.capture(orderId, order.getAmount());\n      logStep(orderId, \"ProcessPayment\", \"DONE\");\n\n      inventoryClient.reserve(orderId, order.getItems());\n      logStep(orderId, \"ReserveInventory\", \"DONE\");\n\n      order.markConfirmed();\n      orderRepo.save(order);\n    } catch (Exception ex) {\n      compensate(order);\n    }\n  }\n\n  @Transactional\n  protected void compensate(Order order) {\n    UUID orderId = order.getId();\n    if (wasDone(orderId, \"ProcessPayment\") && !wasDone(orderId, \"RefundPayment\")) {\n      paymentClient.refund(orderId);\n      logStep(orderId, \"RefundPayment\", \"COMPENSATED\");\n    }\n    order.markCancelled(\"Inventory failed\");\n    orderRepo.save(order);\n  }\n\n  private boolean wasDone(UUID orderId, String step) {\n    return stepLogRepo.existsByOrderIdAndStepAndStatus(orderId, step, \"DONE\");\n  }\n\n  private void logStep(UUID orderId, String step, String status) {\n    stepLogRepo.save(new SagaStepLog(orderId, step, status));\n  }\n}\n```\n\n### Saga step log table (tracks progress)\n```sql\nCREATE TABLE saga_step_log (\n  id UUID PRIMARY KEY,\n  order_id UUID NOT NULL,\n  step TEXT NOT NULL,\n  status TEXT NOT NULL,\n  created_at TIMESTAMP DEFAULT now()\n);\n```\n\n---\n\n## 2️⃣ Kafka event published twice — consumers acted twice. What now?\n\n### Problem\nAt-least-once delivery can produce duplicates. We must make the consumer idempotent.\n\n### Approach\n- Each message has a stable `eventId` (UUID).\n- Consumer stores processed IDs in a table (or cache) and skips duplicates.\n\n### Java code — Idempotent Consumer (Spring Kafka)\n```java\n@Component\n@RequiredArgsConstructor\npublic class InventoryConsumer {\n  private final ProcessedEventRepository processedRepo;\n  private final InventoryService inventoryService;\n\n  @KafkaListener(topics = \"payment-events\", groupId = \"inventory\")\n  public void onPaymentCaptured(PaymentCapturedEvent evt) {\n    if (processedRepo.existsByEventId(evt.getEventId())) return; // duplicate\n\n    try {\n      inventoryService.reserve(evt.getOrderId(), evt.getItems());\n      processedRepo.save(new ProcessedEvent(evt.getEventId()));\n    } catch (Exception e) {\n      throw e; // let retry/DLQ handle\n    }\n  }\n}\n```\n\n### Transactional Outbox (producer side)\nWrite DB change and outbox row in the same transaction. A CDC tool publishes to Kafka.\n```java\n@Entity\n@Table(name = \"outbox\")\npublic class OutboxEvent {\n  @Id UUID eventId;\n  String aggregateId; // orderId or paymentId\n  String type;        // e.g., PaymentCaptured\n  @Lob String payload; // JSON\n  Instant createdAt;\n}\n```\n\n---\n\n## 3️⃣ Three services, one business transaction — 2PC or Saga?\n\n- Prefer Saga. 2PC hurts availability and performance.\n- Use orchestration if you need clear control and monitoring.\n- Use choreography if steps are simple and loosely coupled (each service reacts to events).\n\n### Java code — Choreography example (events only)\n```java\n// Payment publishes PaymentCaptured → Inventory listens and reserves → Order listens and confirms\n```\n\n---\n\n## 4️⃣ Rollback step times out — how to reach a consistent end state?\n\n### Strategy\n- Retry with backoff and jitter.\n- After N failures, send to DLQ.\n- Keep Saga step status so operators can replay compensations from DLQ safely.\n\n### Java code — Retry and DLQ (Spring Kafka)\n```java\n@Bean\npublic ConcurrentKafkaListenerContainerFactory<String, String> kafkaFactory(\n    ConsumerFactory<String, String> cf, KafkaTemplate<String, String> template) {\n  var factory = new ConcurrentKafkaListenerContainerFactory<String, String>();\n  factory.setConsumerFactory(cf);\n  factory.setCommonErrorHandler(new DefaultErrorHandler(\n      new DeadLetterPublishingRecoverer(template),\n      new ExponentialBackOffWithMaxRetries(3)\n  ));\n  return factory;\n}\n```\n\n---\n\n## 5️⃣ Partial failure made data inconsistent — how to detect and fix?\n\n### Detect\n- Nightly job that compares authoritative sources (e.g., Orders vs Payments vs Inventory).\n- Audit log or event store to trace truth.\n\n### Fix\n- Produce corrective events (e.g., `OrderCancelled`, `RefundPayment`).\n- For hard cases, provide a small admin tool to mark and replay compensations.\n\n### Java code — Simple reconciliation job\n```java\n@Component\n@RequiredArgsConstructor\npublic class ReconciliationJob {\n  private final OrderRepository orderRepo;\n  private final PaymentRepository paymentRepo;\n  private final InventoryRepository inventoryRepo;\n\n  @Scheduled(cron = \"0 0 * * * *\")\n  public void reconcile() {\n    var orders = orderRepo.findAllPendingOlderThan(Duration.ofHours(1));\n    for (Order o : orders) {\n      boolean paid = paymentRepo.existsCaptured(o.getId());\n      boolean reserved = inventoryRepo.existsReserved(o.getId());\n      if (paid && !reserved) {\n        // trigger compensation: publish event or call orchestrator to refund\n      }\n    }\n  }\n}\n```\n\n---\n\n## 6️⃣ Orchestrator is a single point of failure — how to mitigate?\n\n- Run orchestrator instances behind a queue; each Saga instance is owned by one worker (sharding by `sagaId`).\n- Persist Saga state in DB so another instance can continue if one dies.\n- Support message replay; handlers must be idempotent.\n\n### Java code — Persisted Saga state (simplified)\n```java\n@Entity\npublic class SagaInstance {\n  @Id UUID sagaId;\n  UUID orderId;\n  String state; // PENDING, PAID, RESERVED, CONFIRMED, CANCELLED\n  Instant updatedAt;\n}\n```\n\n---\n\n## 7️⃣ “Exactly once” across services — what is realistic?\n\nAim for “effectively once”.\n- Producer: Outbox + CDC.\n- Consumer: Idempotency + dedup table.\n- Optional: Store consumed offset with your write in one local DB transaction.\n\n### Java code — Store offset with business write\n```java\n@Transactional\npublic void handle(Event evt) {\n  if (offsetRepo.exists(evt.getPartition(), evt.getOffset())) return;\n  businessWrite(evt);\n  offsetRepo.save(new ConsumedOffset(evt.getPartition(), evt.getOffset()));\n}\n```\n\n---\n\n## Extra scenario prompts (practice)\n- Compensation arrives out of order — enforce sequence numbers per aggregate and detect gaps.\n- Non-compensatable step (email sent) — use forward-only Saga; send correction email if needed.\n- Hot partition causes retry storms — add circuit breakers, rate limits, and per-key backoff.\n- Replay overwhelms downstream — throttle replay, separate catch-up queues.\n\n---\n\n## End-to-end Java example (mini blueprint)\n\n### 1) Outbox entity and save helper\n```java\n@Entity\n@Table(name = \"outbox\")\npublic class OutboxEvent {\n  @Id UUID eventId;\n  String type;\n  String aggregateId;\n  @Lob String payload;\n  Instant createdAt = Instant.now();\n}\n\n@Transactional\npublic void capturePaymentAndOutbox(UUID orderId, BigDecimal amount) {\n  paymentRepo.markCaptured(orderId, amount);\n  OutboxEvent evt = new OutboxEvent();\n  evt.eventId = UUID.randomUUID();\n  evt.type = \"PaymentCaptured\";\n  evt.aggregateId = orderId.toString();\n  evt.payload = toJson(Map.of(\"orderId\", orderId.toString()));\n  outboxRepo.save(evt);\n}\n```\n\n### 2) CDC publishes to Kafka (Debezium config not shown).\n\n### 3) Inventory consumer (idempotent)\n```java\n@KafkaListener(topics = \"payment-events\", groupId = \"inventory\")\npublic void onPaymentCaptured(String json) {\n  PaymentCapturedEvent evt = parse(json);\n  if (processedRepo.existsByEventId(evt.getEventId())) return;\n  inventoryService.reserve(evt.getOrderId(), evt.getItems());\n  processedRepo.save(new ProcessedEvent(evt.getEventId()));\n}\n```\n\n### 4) Orchestrator state transitions stored in DB so crash recovery is safe.\n\n---\n\nIf you remember three things: prefer Sagas over global locks, make every step idempotent, and keep an audit trail (outbox + logs). That’s how you build reliable distributed systems."
}
