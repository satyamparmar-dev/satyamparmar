{
  "title": "Searching & Sorting Master Guide: Visuals, Java Templates, Variants, and LeetCode Sets",
  "slug": "searching-sorting-master-guide",
  "date": "2025-01-20",
  "author": "Satyam Parmar",
  "tags": [
    "DSA",
    "Algorithms",
    "Data Structures",
    "Interview Prep",
    "Backend Engineering"
  ],
  "excerpt": "A senior-architect style playbook for entry-level engineers: how to identify which search or sort to use, step-by-step templates in Java, key variants, complexity cheats, pitfalls, and curated LeetCode practice.",
  "content": "# Searching and Sorting Master Guide\n\nMost problems boil down to: find efficiently or order efficiently. This guide teaches how to recognize the correct searching or sorting approach, when to switch to specialized variants, and how to implement them with small Java templates.\n\n---\n\n## How to Use This Guide\n- Read the identification cues to map a problem to a search/sort family.\n- Start with the Java template, then adapt boundary conditions or comparators.\n- Practice 3 problems per topic; after each, write what went wrong and why.\n- Prefer clarity over micro-optimizations.\n\n---\n\n## Table of Contents\n- Linear Search\n- Binary Search (Index)\n- Binary Search on Answer\n- Ternary Search (Unimodal)\n- Exponential Search\n- Interpolation Search (Theory)\n- Sorting Basics (Stability, In-place)\n- Selection Sort\n- Insertion Sort\n- Bubble Sort (Educational)\n- Merge Sort\n- Quick Sort\n- Heap Sort\n- Counting Sort\n- Radix Sort\n- Bucket Sort\n- Top-K with Heaps\n- Custom Sorting with Comparators\n- Frequency-based Sorting\n\n---\n\n## Linear Search\n\nIdentify when:\n- Small arrays or trivial scan needed.\n- As a building block inside other algorithms.\n\nJava template:\n```java\nint indexOf(int[] a, int target){\n  for (int i = 0; i < a.length; i++) if (a[i] == target) return i;\n  return -1;\n}\n```\n\nLeetCode set: Find the Town Judge 997 (scan degrees); First Bad Version 278 (baseline vs binary); Check if N and Its Double Exist 1346.\n\n---\n\n## Binary Search (Index)\n\nIdentify when:\n- Array is sorted, or you can sort without breaking constraints.\n- Need index, lower bound, upper bound, or first/last occurrence.\n\nVisual:\n```text\nlo .... mid .... hi (predicate monotonic)\n```\nJava template (leftmost >= target):\n```java\nint lowerBound(int[] a, int target){\n  int lo = 0, hi = a.length - 1, ans = a.length;\n  while (lo <= hi){\n    int mid = lo + (hi - lo) / 2;\n    if (a[mid] >= target){ ans = mid; hi = mid - 1; }\n    else lo = mid + 1;\n  }\n  return ans;\n}\n```\n\nVariants:\n- First true / last false; first occurrence / last occurrence.\n- Boundary on custom predicate; binary search on rotated arrays.\n\nLeetCode set: Binary Search 704; Search Insert Position 35; Find First and Last Position 34; Search in Rotated Sorted Array 33; Find Minimum in Rotated Sorted Array 153.\n\n---\n\n## Binary Search on Answer\n\nIdentify when:\n- Answer lies in a numeric range and feasibility is monotonic.\n- Typical in partitioning, capacity, or time minimization problems.\n\nJava template:\n```java\nlong solve(){\n  long lo = L, hi = R, ans = -1;\n  while (lo <= hi){\n    long mid = lo + (hi - lo) / 2;\n    if (feasible(mid)){ ans = mid; hi = mid - 1; } // minimize\n    else lo = mid + 1;\n  }\n  return ans;\n}\n```\n\nLeetCode set: Koko Eating Bananas 875; Capacity To Ship Packages Within D Days 1011; Split Array Largest Sum 410; Min Speed On Time 1870.\n\n---\n\n## Ternary Search (Unimodal)\n\nIdentify when:\n- Function is unimodal (strictly increasing then decreasing or vice versa).\n- Search for maximum/minimum of continuous or discrete function.\n\nJava template (discrete):\n```java\nint ternary(int lo, int hi){\n  while (hi - lo > 2){\n    int m1 = lo + (hi - lo) / 3;\n    int m2 = hi - (hi - lo) / 3;\n    if (f(m1) < f(m2)) lo = m1; else hi = m2;\n  }\n  int best = lo;\n  for (int x = lo + 1; x <= hi; x++) if (f(x) > f(best)) best = x;\n  return best;\n}\n```\n\nProblems to explore: Maximum Value at a Given Index 1802 (can be solved via BS on answer; conceptually unimodal).\n\n---\n\n## Exponential Search\n\nIdentify when:\n- Unknown size stream or infinite array abstraction.\n- Find bounds exponentially, then binary search.\n\nJava template:\n```java\nint expoSearch(int[] a, int x){\n  if (a.length == 0) return -1;\n  int bound = 1;\n  while (bound < a.length && a[bound] < x) bound <<= 1;\n  int lo = bound >> 1, hi = Math.min(bound, a.length - 1);\n  // binary search in [lo, hi]\n  while (lo <= hi){\n    int mid = lo + (hi - lo) / 2;\n    if (a[mid] == x) return mid;\n    if (a[mid] < x) lo = mid + 1; else hi = mid - 1;\n  }\n  return -1;\n}\n```\n\n---\n\n## Interpolation Search (Theory)\n\nUse rarely in interviews; assumes uniform distribution to guess position. Prefer binary search in practice.\n\n---\n\n## Sorting Basics\n\nKnow these terms:\n- Stable vs unstable; in-place vs extra memory.\n- Comparison sort lower bound: O(n log n).\n- Non-comparison sorts (counting, radix, bucket) rely on domain constraints.\n\nComplexities (typical):\n- Merge: O(n log n) time, O(n) space, stable.\n- Quick: average O(n log n), worst O(n^2), in-place, unstable.\n- Heap: O(n log n), in-place (array heap), unstable.\n\n---\n\n## Selection Sort (Educational)\n\nJava template:\n```java\nfor (int i = 0; i < n; i++){\n  int min = i;\n  for (int j = i + 1; j < n; j++) if (a[j] < a[min]) min = j;\n  int t = a[i]; a[i] = a[min]; a[min] = t;\n}\n```\n\n---\n\n## Insertion Sort\n\nIdentify when:\n- Nearly sorted arrays; online insertion.\n\nJava template:\n```java\nfor (int i = 1; i < n; i++){\n  int key = a[i], j = i - 1;\n  while (j >= 0 && a[j] > key){ a[j+1] = a[j]; j--; }\n  a[j+1] = key;\n}\n```\n\nLeetCode set: Insertion Sort List 147; Sort Colors 75 (3-way partition variant).\n\n---\n\n## Bubble Sort (Educational)\n\nUse only for teaching swaps and invariants.\n\n---\n\n## Merge Sort\n\nIdentify when:\n- Need stable sort; easy to adapt for counting inversions or merging k lists.\n\nJava template:\n```java\nvoid mergeSort(int[] a, int l, int r, int[] tmp){\n  if (l >= r) return;\n  int m = l + (r - l) / 2;\n  mergeSort(a, l, m, tmp);\n  mergeSort(a, m+1, r, tmp);\n  int i=l, j=m+1, k=l;\n  while (i<=m && j<=r){\n    if (a[i] <= a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++];\n  }\n  while (i<=m) tmp[k++] = a[i++];\n  while (j<=r) tmp[k++] = a[j++];\n  for (int t=l; t<=r; t++) a[t] = tmp[t];\n}\n```\n\nLeetCode set: Merge Two Sorted Lists 21; Sort List 148; Count of Smaller Numbers After Self 315 (merge + counts).\n\n---\n\n## Quick Sort\n\nIdentify when:\n- In-place, average O(n log n), 3-way partition for many duplicates.\n\nJava template (Lomuto):\n```java\nint partition(int[] a, int l, int r){\n  int pivot = a[r];\n  int i = l;\n  for (int j=l; j<r; j++){\n    if (a[j] <= pivot){ int t=a[i]; a[i]=a[j]; a[j]=t; i++; }\n  }\n  int t=a[i]; a[i]=a[r]; a[r]=t;\n  return i;\n}\nvoid quick(int[] a, int l, int r){\n  if (l >= r) return;\n  int p = partition(a, l, r);\n  quick(a, l, p-1); quick(a, p+1, r);\n}\n```\n\nVariant: Hoare partition; 3-way partition for duplicates.\n\nLeetCode set: Kth Largest Element in an Array 215 (quickselect); Sort Colors 75 (Dutch flag); Largest Number 179 (custom comparator).\n\n---\n\n## Heap Sort\n\nIdentify when:\n- Need in-place O(n log n) without recursion limits.\n\nJava template:\n```java\nvoid heapSort(int[] a){\n  int n=a.length;\n  for(int i=n/2-1;i>=0;i--) siftDown(a,i,n);\n  for(int end=n-1; end>0; end--){\n    int t=a[0]; a[0]=a[end]; a[end]=t;\n    siftDown(a,0,end);\n  }\n}\nvoid siftDown(int[] a,int i,int n){\n  while(true){\n    int l=2*i+1, r=2*i+2, best=i;\n    if(l<n && a[l]>a[best]) best=l;\n    if(r<n && a[r]>a[best]) best=r;\n    if(best==i) break;\n    int t=a[i]; a[i]=a[best]; a[best]=t;\n    i=best;\n  }\n}\n```\n\n---\n\n## Counting Sort\n\nIdentify when:\n- Keys in small integer range [0..K].\n\nJava template:\n```java\nint[] countSort(int[] a, int K){\n  int n=a.length; int[] cnt=new int[K+1];\n  for(int x: a) cnt[x]++;\n  for(int i=1;i<=K;i++) cnt[i]+=cnt[i-1];\n  int[] out=new int[n];\n  for(int i=n-1;i>=0;i--) out[--cnt[a[i]]] = a[i]; // stable\n  return out;\n}\n```\n\nLeetCode set: Sort Characters By Frequency 451 (freq then custom sort).\n\n---\n\n## Radix Sort\n\nIdentify when:\n- Integers with bounded digits (base 10 or base 2^k).\n\nJava sketch (LSD, uses counting per digit):\n```java\nvoid radixSort(int[] a){\n  int max=0; for(int x: a) max=Math.max(max,x);\n  for(int exp=1; max/exp>0; exp*=10) countByDigit(a,exp);\n}\n```\n\nProblems: Maximum Gap 164 (radix or bucket); Sort Integers by The Number of 1 Bits 1356 (then comparator).\n\n---\n\n## Bucket Sort\n\nIdentify when:\n- Values roughly uniform over a range; near-linear expected time.\n\nExample use: Maximum Gap 164 (bucket by range).\n\n---\n\n## Top-K with Heaps\n\nIdentify when:\n- Need k largest/smallest or stream processing.\n\nJava template:\n```java\nPriorityQueue<Integer> h = new PriorityQueue<>(); // min-heap\nfor(int x: a){\n  h.offer(x);\n  if(h.size()>k) h.poll();\n}\n// heap has k largest\n```\n\nLeetCode set: Top K Frequent Elements 347; Kth Largest Element 215; Find K Pairs With Smallest Sums 373.\n\n---\n\n## Custom Sorting with Comparators\n\nIdentify when:\n- Need domain-specific order.\n\nJava template:\n```java\nArrays.sort(arr, (u,v) -> {\n  // return negative if u before v, positive if after, 0 if equal\n  return key(u) - key(v);\n});\n```\n\nLeetCode set: Largest Number 179; Reorder Log Files 937; Sort the Jumbled Numbers 2191.\n\n---\n\n## Frequency-based Sorting\n\nIdentify when:\n- Sort by frequency, then by value or other tie-breakers.\n\nJava template:\n```java\nMap<Integer,Integer> f = new HashMap<>();\nfor(int x: a) f.put(x, f.getOrDefault(x,0)+1);\nList<Integer> list = new ArrayList<>(f.keySet());\nCollections.sort(list, (u,v) -> {\n  int cu=f.get(u), cv=f.get(v);\n  if (cu!=cv) return cv-cu; // desc by freq\n  return u-v;\n});\n```\n\nLeetCode set: Sort Characters By Frequency 451; Frequency Sort 1636; Relative Sort Array 1122.\n\n---\n\n## Pitfalls and Checks\n- Off-by-one in binary search (while condition, mid updates).\n- Stability assumptions when merging or counting.\n- Pivot choice in quick sort (3-way for duplicates).\n- Overflow in mid = (lo+hi)/2 (use lo + (hi-lo)/2).\n- Comparator must be anti-symmetric and transitive.\n\n## Practice Plan\n- Day 1: Binary Search (index + on answer).\n- Day 2: Merge Sort + Quick Sort.\n- Day 3: Heaps (top-k, heap sort).\n- Day 4: Counting/Radix/Bucket.\n- Day 5: Custom sorting with comparators; frequency sort.\n- Retrospective: write 5-line takeaways after each session.\n"
}
