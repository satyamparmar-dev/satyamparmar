{
  "title": "System Design Power-Guide 2025: What To Learn, In What Order, With Real-World Links",
  "slug": "system-design-resources-2025",
  "date": "2025-01-20",
  "author": "Satyam Parmar",
  "tags": [
    "Backend Engineering",
    "System Design",
    "Distributed Systems",
    "Architecture",
    "Resources"
  ],
  "excerpt": "Stop bookmarking random threads. This is a tight, no-fluff map of what to study for system design in 2025 - what each topic is, why it matters in interviews and production, and where to go deeper.",
  "content": "# System Design Power-Guide 2025\n\nYou don't need another 300-link dump. You need a sequence. Learn the few pillars that show up in every interview and every production incident, then branch out with purpose. This guide gives you that path - topic by topic, with crisp reasons and curated jump-off points.\n\n---\n\n## 1. API and Web Basics (Non-Negotiable)\n- What to know: HTTP lifecycle, headers, caching, TLS, proxies, API styles (REST, GraphQL, gRPC).\n- Why it matters: Every system is a networked system; poor API design cascades into scale and reliability issues.\n- Study path: Short/long polling vs SSE vs WebSocket, Reverse Proxy vs API Gateway, pagination patterns, versioning, idempotency.\n\n## 2. Caching and Performance\n- What to know: Local vs global caches, eviction policies (LRU/LFU), stampede protection, TTL design.\n- Why it matters: Most systems fail first on read latency under load; cache correctness affects data trust.\n- Study path: CDN internals, Redis persistence and performance, cache invalidation strategies, autocomplete and search caching.\n\n## 3. Databases and Storage\n- What to know: SQL vs NoSQL, sharding, replication, consistency levels, LSM vs B-Tree, time series trade-offs.\n- Why it matters: Partition keys, indexes, and replica topology decide your bottlenecks and blast radius.\n- Study path: Dynamo-style KV, Cassandra/Bigtable, Postgres replication, CDC, object storage and durability (S3).\n\n## 4. Messaging and Streams\n- What to know: Queues vs logs, delivery semantics, consumer groups, backpressure, idempotency/outbox.\n- Why it matters: Most scalable systems are event-driven; failures hide in retries and ordering.\n- Study path: Kafka fundamentals, DLQ patterns, stream processing, exactly-once myths and practical \"effectively-once\".\n\n## 5. Compute and Orchestration\n- What to know: Containers, scheduling, autoscaling, blue/green and canary, rollbacks.\n- Why it matters: Releases and elasticity are reliability features, not ops afterthoughts.\n- Study path: Kubernetes services and patterns, CI/CD flows, IaC hygiene, fault injection.\n\n## 6. Cloud and Scalability\n- What to know: Horizontal vs vertical scaling, multi-AZ/region patterns, resiliency, cost controls.\n- Why it matters: \"Works on my laptop\" ends the moment traffic spikes or a zone blips.\n- Study path: Load balancers, rate limiting, retries with jitter, distributed locks, unique ID generators, HA playbooks.\n\n## 7. Security and Auth\n- What to know: OAuth/OIDC, sessions vs JWT, token storage, TLS, secrets management.\n- Why it matters: Auth bugs become front-page outages; PCI/PII rules affect architecture.\n- Study path: Permission models, token lifecycles, password storage, mTLS, API hardening.\n\n## 8. Observability and Operations\n- What to know: Metrics, logs, traces, SLOs, error budgets, incident flow.\n- Why it matters: You cannot scale what you cannot see; design for debugging from day one.\n- Study path: Time-series storage, sampling, cardinality strategies, structured logging, trace-based debugging.\n\n---\n\n## Curated Jump-Off List (Start Here)\nBelow is a compact set of representative topics to explore in each area. Use these as prompts to find official docs and deep dives.\n\n### API and Web\n- How HTTP/2 and HTTP/3 change latency.\n- REST vs GraphQL vs gRPC trade-offs.\n- API Gateway vs Reverse Proxy.\n- Pagination patterns and pitfalls.\n\n### Real Systems to Dissect\n- Twitter timeline ranking and search signals.\n- YouTube upload pipeline and CDN fanout.\n- Netflix caching and data stores.\n- Discord trillions-of-messages storage.\n\n### Databases\n- Sharding algorithms and partition keys.\n- Dynamo-style KV internals.\n- LSM tree vs B-Tree fundamentals.\n- Read replicas and lag management.\n\n### Messaging\n- Kafka consumer groups and offsets.\n- Delivery semantics and DLQ strategies.\n- CDC and stream processors.\n- Fanout patterns for notifications.\n\n### Cloud & Scale\n- AWS typical network blueprints.\n- Autoscaling and graceful degradation.\n- Multi-region: routing, config, drift.\n- Distributed locks and fencing tokens.\n\n### Security\n- OAuth flows and token lifetimes.\n- Sessions vs JWT storage trade-offs.\n- TLS handshake and pinning.\n- Designing enterprise authorization.\n\n### Observability\n- High-cardinality metrics at scale.\n- Trace sampling and correlation.\n- Alerting vs SLO-based burn alerts.\n- Incident review checklists.\n\n---\n\n## How to Practice (Weekly Repeatable Loop)\n- Pick one system (e.g., URL shortener).\n- Define API, data model, scaling plan, and failure modes.\n- Do back-of-the-envelope capacity estimates.\n- Write down cache keys, TTLs, and invalidation rules.\n- Decide which paths must be strongly consistent vs eventually consistent.\n- Review trade-offs with a buddy or rubber-duck it in a doc.\n\n## Interview Mode (Signals Interviewers Look For)\n- Clear requirements and constraints.\n- Data model and partition keys aligned with access patterns.\n- Caching strategy that avoids stampede and staleness traps.\n- Thoughtful trade-offs: fanout vs fan-in, write vs read, latency vs cost.\n- Resiliency plan: retries, idempotency, DLQs, circuit breakers.\n- Evolution plan: MVP first, then shards, then regions.\n\n---\n\n"
}
