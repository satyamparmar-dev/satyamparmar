{
  "title": "DSA Patterns Master Guide: How To Identify Problems, Pick Patterns, and Practice (With LeetCode Sets)",
  "slug": "dsa-patterns-master-guide",
  "date": "2025-01-20",
  "author": "Satyam Parmar",
  "tags": [
    "DSA",
    "Algorithms",
    "Data Structures",
    "Interview Prep",
    "Backend Engineering"
  ],
  "excerpt": "A practical, pattern-first road map for entry-level engineers. Learn how to identify the right pattern quickly, apply a small algorithm template, know variants and pitfalls, and practice with curated LeetCode problems.",
  "content": "# DSA Patterns Master Guide\n\nMost interview problems are variants of a small set of patterns. Your job is not to memorize 500 solutions, but to map a problem to a pattern, recall a small algorithm template, and adapt it. This guide shows you how to identify each pattern, when to use it, the typical steps, common pitfalls, and a focused LeetCode practice set.\n\n---\n\n## How to Use This Guide\n- Read the identification cues. Train your eyes to spot keywords and shapes.\n- Memorize the small algorithm steps. Build the solution skeleton first.\n- Practice 3 to 5 problems per pattern with spaced repetition.\n- After solving, write a 5 line retrospective: pattern, key decision, complexity, 1 pitfall, 1 variation.\n\n---\n\n## Two Pointers\n\nVisual:\n```text\nhead <---- array ----> tail\nl ->  .........  <- r\nfast/slow for cycle detection\n```\nJava template:\n```java\nint l = 0, r = nums.length - 1;\nwhile (l < r) {\n  long sum = (long) nums[l] + nums[r];\n  if (sum == target) { /* use/update */ l++; r--; }\n  else if (sum < target) l++;\n  else r--;\n}\n```\n\n- Identify it when:\n  - Array or string, sorted or sortable.\n  - Need pair, triplet, or partitioning.\n  - Move pointers inward or with fast-slow positions.\n- Core options: head-tail inward, same direction fast-slow, in-place partitioning.\n- Steps template:\n  1. Sort if needed.\n  2. Initialize left and right or slow and fast.\n  3. Move based on comparison, update answer, avoid duplicates.\n- Pitfalls: off-by-one, duplicate handling, infinite loops when both pointers fail to move.\n- Complexity: O(n) or O(n log n) with sort, O(1) extra space.\n- LeetCode set: Reverse String 344; Two Sum II 167; Remove Duplicates from Sorted Array 26; Container With Most Water 11; Trapping Rain Water 42.\n\n## Sliding Window\n\nVisual:\n```text\n[l ........ r]  grow r; while invalid -> shrink l\n```\nJava template (variable window):\n```java\nint l = 0;\nMap<Character,Integer> freq = new HashMap<>();\nint best = 0;\nfor (int r = 0; r < s.length(); r++) {\n  char c = s.charAt(r);\n  freq.put(c, freq.getOrDefault(c, 0) + 1);\n  while (!isValid(freq)) {\n    char d = s.charAt(l++);\n    freq.put(d, freq.get(d) - 1);\n    if (freq.get(d) == 0) freq.remove(d);\n  }\n  best = Math.max(best, r - l + 1);\n}\n```\n\n- Identify it when:\n  - Substring or subarray with length k, or best score within constraints.\n  - Max, min, first, shortest, or longest subarray meeting a property.\n- Options: fixed size, growing-shrinking, frequency maps for distinct or count constraints.\n- Steps template:\n  1. Expand right, add element to state.\n  2. While invalid, shrink left, remove from state.\n  3. Track best answer during valid windows.\n- Pitfalls: forgetting to shrink, not updating answer at correct time, wrong invariant.\n- Complexity: O(n).\n- LeetCode set: Maximum Sum Subarray of Size K (educative style); Longest Substring Without Repeating Characters 3; Minimum Size Subarray Sum 209; Longest Repeating Character Replacement 424; Sliding Window Maximum 239.\n\n## Prefix Sum\n\nVisual:\n```text\nP[i] = a[0] + ... + a[i];  sum(l..r) = P[r] - P[l-1]\n```\nJava template (subarray sum = k):\n```java\nMap<Integer,Integer> seen = new HashMap<>();\nseen.put(0, 1);\nint pref = 0, count = 0;\nfor (int x : nums) {\n  pref += x;\n  count += seen.getOrDefault(pref - k, 0);\n  seen.put(pref, seen.getOrDefault(pref, 0) + 1);\n}\n```\n\n- Identify it when:\n  - Range sum or count of something in a range.\n  - Need O(1) queries after O(n) preprocessing or subarray sums with hash map.\n- Options: plain prefix sums; prefix counts; prefix modulo for divisible subarrays.\n- Steps template:\n  1. Maintain running prefix.\n  2. Use hash map to store first seen prefix or counts.\n  3. Query subarray via prefix[j] - prefix[i-1] or map lookups.\n- Pitfalls: off-by-one with index 0; clearing map incorrectly.\n- LeetCode set: Running Sum 1480; Subarray Sum Equals K 560; Find Pivot Index 724; Continuous Subarray Sum 523; Range Sum Query 303.\n\n## Binary Search\n\nVisual:\n```text\nlo .... mid .... hi   (predicate monotonic)\n```\nJava template (leftmost true):\n```java\nint lo = L, hi = R, ans = -1;\nwhile (lo <= hi) {\n  int mid = lo + (hi - lo) / 2;\n  if (check(mid)) { ans = mid; hi = mid - 1; }\n  else lo = mid + 1;\n}\n```\n\n- Identify it when:\n  - Array is sorted or answer is monotonic in a search space.\n  - You can ask: if I pick mid, should I go left or right.\n- Options: index search, boundary search, binary search on answer.\n- Steps template:\n  1. low, high; while low <= high.\n  2. mid; check condition C(mid).\n  3. Move low or high; track best boundary.\n- Pitfalls: infinite loop when mid calculation or update is wrong; off-by-one on boundaries.\n- LeetCode set: Binary Search 704; Search Insert Position 35; Search in Rotated Sorted Array 33; Find Minimum in Rotated Sorted Array 153; Median of Two Sorted Arrays 4.\n\n## Intervals and Merge\n\nVisual:\n```text\n---- ----    -----   --\n  \u005c___merge___/   push\n```\nJava template (merge intervals):\n```java\nArrays.sort(iv, (a,b) -> Integer.compare(a[0], b[0]));\nList<int[]> res = new ArrayList<>();\nfor (int[] cur : iv) {\n  if (res.isEmpty() || cur[0] > res.get(res.size()-1)[1]) res.add(new int[]{cur[0], cur[1]});\n  else res.get(res.size()-1)[1] = Math.max(res.get(res.size()-1)[1], cur[1]);\n}\n```\n\n- Identify it when:\n  - Merge, insert, or schedule non-overlapping intervals.\n- Options: sort by start; sweep line; priority queue by end time.\n- Steps template:\n  1. Sort by start.\n  2. If overlap with last, merge; else push.\n  3. For meeting rooms, track end times in min-heap.\n- LeetCode set: Merge Intervals 56; Insert Interval 57; Meeting Rooms II 253; Non-overlapping Intervals 435; Employee Free Time 759.\n\n## Trees (DFS and BFS)\n\nVisual:\n```text\n   n\n  / \\n l   r\n```\nJava template (DFS):\n```java\nint dfs(TreeNode node) {\n  if (node == null) return 0;\n  int L = dfs(node.left), R = dfs(node.right);\n  return combine(L, R, node);\n}\n```\n\n- Identify it when:\n  - Binary tree traversal, path sums, symmetric or balanced checks.\n- Options: pre/in/post-order DFS; BFS level order; recursion vs stack.\n- Steps template:\n  1. Choose traversal order.\n  2. Define function(node) -> combine child results.\n  3. Handle base case null.\n- LeetCode set: Maximum Depth of Binary Tree 104; Symmetric Tree 101; Binary Tree Level Order Traversal 102; Lowest Common Ancestor 236; Serialize and Deserialize Binary Tree 297.\n\n## Graphs\n\nVisual:\n```text\nTopo: queue of indegree==0\nBFS: frontier layers\n```\nJava template (Topo Kahn):\n```java\nQueue<Integer> q = new ArrayDeque<>();\nfor (int i = 0; i < n; i++) if (indeg[i] == 0) q.add(i);\nList<Integer> order = new ArrayList<>();\nwhile (!q.isEmpty()) {\n  int u = q.poll(); order.add(u);\n  for (int v : adj[u]) if (--indeg[v] == 0) q.add(v);\n}\n```\n\n- Identify it when:\n  - Connectivity, shortest path, topological order, or components.\n- Options: BFS, DFS, Dijkstra, Union-Find, Kahn for topo, cycle detection.\n- Steps template:\n  1. Build adjacency list.\n  2. Pick traversal based on weights.\n  3. Track visited, parent, or distance.\n- LeetCode set: Number of Islands 200; Clone Graph 133; Course Schedule 207; Word Ladder 127; Network Delay Time 743.\n\n## Linked List\n\nVisual:\n```text\nhead -> a -> b -> c\n```\nJava template (reverse):\n```java\nListNode prev = null, cur = head;\nwhile (cur != null) {\n  ListNode nxt = cur.next;\n  cur.next = prev; prev = cur; cur = nxt;\n}\n```\n\n- Identify it when:\n  - Reversals, merging, cycle detection, reordering.\n- Options: fast-slow pointers; dummy head; in-place reverse.\n- Steps template:\n  1. Use dummy; split or reverse part.\n  2. Connect carefully with saved next.\n  3. Use fast-slow for cycle and middle.\n- LeetCode set: Reverse Linked List 206; Linked List Cycle 141; Merge Two Sorted Lists 21; Add Two Numbers 2; Copy List with Random Pointer 138.\n\n## Stack and Monotonic Stack\n\nVisual:\n```text\nMaintain increasing/decreasing stack of indices\n```\nJava template (monotonic):\n```java\nint n = nums.length;\nint[] ans = new int[n];\nDeque<Integer> st = new ArrayDeque<>();\nfor (int i = 0; i < n; i++) {\n  while (!st.isEmpty() && breakCond(nums[st.peek()], nums[i])) {\n    int j = st.pop(); ans[j] = i - j;\n  }\n  st.push(i);\n}\n```\n\n- Identify it when:\n  - Next greater element, valid parentheses, span or histogram problems.\n- Options: plain stack for validation; monotonic increasing or decreasing stacks.\n- Steps template:\n  1. For parentheses, push expected closers.\n  2. For monotonic, pop while break condition, compute area or distance.\n  3. Push current with index/value.\n- LeetCode set: Valid Parentheses 20; Min Stack 155; Daily Temperatures 739; Next Greater Element II 503; Largest Rectangle in Histogram 84.\n\n## Dynamic Programming\n\nVisual:\n```text\nTable f[i][j] or 1D rolling array\n```\nJava template (bottom-up):\n```java\nfor (int i = 0; i <= n; i++) {\n  for (int j = 0; j <= m; j++) {\n    dp[i][j] = bestOfChoices(i,j);\n  }\n}\n```\n\n- Identify it when:\n  - Overlapping subproblems, optimal substructure, count ways or max score.\n- Options: 1D or 2D DP, knapsack, LIS, partition, edit distance.\n- Steps template:\n  1. Define state f(i, j).\n  2. Write recurrence from choices.\n  3. Order of evaluation bottom-up; or memoize top-down.\n- LeetCode set: Climbing Stairs 70; House Robber 198; Longest Increasing Subsequence 300; Coin Change 322; Edit Distance 72.\n\n## Backtracking\n\nVisual:\n```text\nchoose -> explore -> undo\n```\nJava template:\n```java\nList<List<Integer>> ans = new ArrayList<>();\nvoid dfs(int i) {\n  if (done(i)) { ans.add(new ArrayList<>(path)); return; }\n  for (int c : choices(i)) {\n    if (!feasible(c)) continue;\n    apply(c); path.add(c);\n    dfs(next(i));\n    path.remove(path.size()-1); undo(c);\n  }\n}\n```\n\n- Identify it when:\n  - Search all combinations, permutations, n-queens, subsets with constraints.\n- Options: choose or skip; for loops with start index; pruning with feasibility checks.\n- Steps template:\n  1. Add current choice.\n  2. Recurse to next position.\n  3. Backtrack by undoing choice.\n- LeetCode set: Subsets 78; Permutations 46; Combination Sum 39; N-Queens 51; Word Search 79.\n\n## Heap and Priority Queue\n\nVisual:\n```text\nMaintain size K; max-heap or min-heap by need\n```\nJava template (top K):\n```java\nPriorityQueue<int[]> h = new PriorityQueue<>((a,b)->a[0]-b[0]);\nfor (int[] x : items) {\n  h.offer(x);\n  if (h.size() > K) h.poll();\n}\n```\n\n- Identify it when:\n  - Top K, running median, scheduling by earliest finishing or highest frequency.\n- Options: min-heap, max-heap, custom comparator, heap of heaps.\n- Steps template:\n  1. Push candidates with priority.\n  2. Pop to maintain size K or pick next job.\n  3. For streaming, rebalance two heaps.\n- LeetCode set: Kth Largest Element in an Array 215; Top K Frequent Elements 347; Merge K Sorted Lists 23; Reorganize String 767; Find Median from Data Stream 295.\n\n## Greedy\n\nVisual:\n```text\nsort by key; take if feasible\n```\nJava template:\n```java\nArrays.sort(items, (a,b) -> key(a) - key(b));\nfor (var it : items) if (feasible(it)) take(it);\n```\n\n- Identify it when:\n  - Local choices lead to global optimum for scheduling, intervals, or coin-like problems.\n- Options: sort by a ratio, earliest finish, or difference; prove exchange argument.\n- Steps template:\n  1. Sort by greedy key.\n  2. Pick if feasible; skip otherwise.\n  3. Maintain running answer.\n- LeetCode set: Assign Cookies 455; Jump Game 55; Gas Station 134; Task Scheduler 621; Candy 135.\n\n## Bit Manipulation\n\nVisual:\n```text\nXOR cancels pairs; masks enumerate subsets\n```\nJava template:\n```java\nint ans = 0;\nfor (int x : nums) ans ^= x;\n```\n\n- Identify it when:\n  - Parity, unique number among duplicates, subsets via bitmasks.\n- Options: XOR, bit count, bit DP, masks.\n- Steps template:\n  1. Use XOR to cancel pairs.\n  2. Shift and mask to test bits.\n  3. Precompute bit counts if needed.\n- LeetCode set: Single Number 136; Number of 1 Bits 191; Counting Bits 338; Sum of Two Integers 371; Maximum Product of Word Lengths 318.\n\n## Union-Find (Disjoint Set)\n\nVisual:\n```text\nparent + rank; path compression\n```\nJava template:\n```java\nint find(int x){ return p[x]==x? x : (p[x]=find(p[x])); }\nvoid unite(int a,int b){ int ra=find(a), rb=find(b); if (ra==rb) return; if (rank[ra]<rank[rb]) p[ra]=rb; else if (rank[rb]<rank[ra]) p[rb]=ra; else { p[rb]=ra; rank[ra]++; } }\n```\n\n- Identify it when:\n  - Grouping connectivity, number of components, cycle detection in undirected graphs.\n- Options: union by rank, path compression, union by size.\n- Steps template:\n  1. Make set for every node.\n  2. For every edge, union(u, v).\n  3. Count unique parents.\n- LeetCode set: Number of Provinces 547; Redundant Connection 684; Accounts Merge 721; Graph Valid Tree 261; Smallest String With Swaps 1202.\n\n## Math and Geometry\n\nVisual:\n```text\nUse identities; cross product for orientation\n```\nJava snippet (fast pow):\n```java\nlong pow(long a, long e){ long r=1; while(e>0){ if((e&1)==1) r*=a; a*=a; e>>=1; } return r; }\n```\n\n- Identify it when:\n  - Pure math function or geometric constraints.\n- Options: binary exponentiation, integer sqrt, vector cross product, angle sorting.\n- Steps template:\n  1. Reduce using algebraic identity.\n  2. Watch overflow and precision.\n  3. Use geometry primitives.\n- LeetCode set: Power of Two 231; Sqrt(x) 69; Happy Number 202; Plus One 66; Rotate Image 48.\n\n## Design, LRU, and System-Style Questions\n\nVisual:\n```text\nHashMap + DoublyLinkedList -> O(1) get/put/evict\n```\nJava sketch (LRU core):\n```java\nclass LRU {\n  static class Node{int k,v; Node p,n;}\n  Map<Integer,Node> map = new HashMap<>();\n  Node h = new Node(), t = new Node();\n  LRU(){ h.n=t; t.p=h; }\n  void moveFront(Node x){ remove(x); insertAfter(h,x);}\n  void insertAfter(Node a, Node x){ x.n=a.n; x.p=a; a.n.p=x; a.n=x; }\n  void remove(Node x){ x.p.n=x.n; x.n.p=x.p; }\n}\n```\n\n- Identify it when:\n  - Caching, rate limiting, LFU/LRU, simple system components.\n- Options: hashmap + doubly linked list; counters with TTL; token bucket.\n- Steps template:\n  1. Design API surface.\n  2. Pick core data structure pair.\n  3. Define complexity and eviction behavior.\n- LeetCode set: Min Stack 155; LRU Cache 146; LFU Cache 460; Design Twitter 355; Serialize and Deserialize Binary Tree 297.\n\n---\n\n## Practice Plan\n- Week 1: Two Pointers, Sliding Window, Prefix Sum.\n- Week 2: Binary Search, Intervals, Trees.\n- Week 3: Graphs, Linked List, Stack.\n- Week 4: DP, Backtracking.\n- Week 5: Heap, Greedy, Bit Manipulation.\n- Week 6: Union-Find, Math, Design.\n\nFor each pattern session: solve 3 problems blind, then 1 timed, then explain out loud the choices, invariants, and complexity.\n\n## Pattern Decision Cheat Sheet\n- Subarray with constraint -> Sliding Window.\n- Range sums -> Prefix Sum.\n- Sorted or monotone answer -> Binary Search.\n- Merge or schedule -> Intervals + Greedy or Heap.\n- Paths, connectivity -> Graph + BFS/DFS or Union-Find.\n- Build from choices -> DP or Backtracking.\n- Top K or stream -> Heap.\n- Next greater or validation -> Stack or Monotonic Stack.\n\n---\n\n## Table of Contents\n- Two Pointers\n- Sliding Window\n- Prefix Sum\n- Binary Search\n- Intervals and Merge\n- Trees (DFS and BFS)\n- Graphs\n- Linked List\n- Stack and Monotonic Stack\n- Dynamic Programming\n- Backtracking\n- Heap and Priority Queue\n- Greedy\n- Bit Manipulation\n- Union-Find (Disjoint Set)\n- Math and Geometry\n- Design, LRU, and System-Style Questions\n"
}
